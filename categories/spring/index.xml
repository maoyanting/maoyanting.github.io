<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spring on 修仙下属委员会</title>
    <link>https://maoyanting.github.io/categories/spring/</link>
    <description>Recent content in Spring on 修仙下属委员会</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 22 Oct 2018 22:49:08 +0000</lastBuildDate>
    
	<atom:link href="https://maoyanting.github.io/categories/spring/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Spring-sleuth</title>
      <link>https://maoyanting.github.io/post/spring-sleuth/</link>
      <pubDate>Mon, 22 Oct 2018 22:49:08 +0000</pubDate>
      
      <guid>https://maoyanting.github.io/post/spring-sleuth/</guid>
      <description>&lt;p&gt;有时候，定位bug真的是个很麻烦的事情呢&lt;/p&gt;

&lt;p&gt;我们可以简单借用一下Spring Cloud Sleuth&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Spring-全局异常拦截</title>
      <link>https://maoyanting.github.io/post/spring-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA/</link>
      <pubDate>Tue, 16 Oct 2018 15:49:06 +0000</pubDate>
      
      <guid>https://maoyanting.github.io/post/spring-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA/</guid>
      <description>&lt;p&gt;Spring MVC那一篇里提到了异常拦截来做参数校验返回，那里是对特定的 &lt;code&gt;controller&lt;/code&gt; 做异常捕捉，但是我们也可以选择全局拦截处理&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Spring（未完）</title>
      <link>https://maoyanting.github.io/post/spring/</link>
      <pubDate>Mon, 17 Sep 2018 11:56:06 +0000</pubDate>
      
      <guid>https://maoyanting.github.io/post/spring/</guid>
      <description>&lt;p&gt;spring 是一个 &lt;strong&gt;轻量级&lt;/strong&gt;的 实现&lt;strong&gt;IOC&lt;/strong&gt; 和 &lt;strong&gt;AOP&lt;/strong&gt;的框架。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Spring-注释</title>
      <link>https://maoyanting.github.io/post/spring-%E6%B3%A8%E9%87%8A/</link>
      <pubDate>Thu, 11 Jan 2018 15:49:06 +0000</pubDate>
      
      <guid>https://maoyanting.github.io/post/spring-%E6%B3%A8%E9%87%8A/</guid>
      <description>注释 @Component： 功能：表明该类会作为组件类，并告知Spring要为此创建bean
下述这 3 个注释和 @Component 是等效的，但是从注释类的命名上，很容易看出这 3 个注释分别和持久层、业务层和控制层（Web 层）相对应。
@Service 用于标注业务层组件
@Controller 用于标注控制层组件
@Repository 用于标注数据访问组件，即DAO组件
@Component 泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。
@ComponentScan： 功能：在Spring中启用组件扫描（默认组件扫描不启动），默认扫描与配置类相同的包；
@ComponentScan（”packageName&amp;rdquo;）
指明是基础包：@ComponentScan（basePackages=”package1Name”）@ComponentScan（basePackages={”package1Name”,”package2Name”}）
另一种方式：@ComponentScan（basePackagesClasses={ package1Name.class , package2Name.class } ）
@Autowired: 功能：声明要进行自动装配
使用：在构造器和方法 上
默认按类型装配，默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用。
加上@Autowired后不需要getter()和setter()方法，Spring也会自动注入。
@Qualifier 功能：按名字装配bean
当我们在 Spring 容器中配置了两个类型为 Office 类型的 Bean，当对 Boss 的 office 成员变量进行自动注入时，Spring 容器将无法确定到底要用哪一个 Bean，就会发生异常。
Spring 允许我们通过 @Qualifier 注释指定注入 Bean 的名称，这样歧义就消除了，所以 @Autowired 和 @Qualifier 结合使用时，自动注入的策略就从 byType 转变成 byName 了。
@Resource 功能：按名字装配bean
是JDK1.6支持的注解（非Spring），默认按照名称进行装配。
名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名，按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。
@Configuration： 表明此类是个配置类</description>
    </item>
    
  </channel>
</rss>