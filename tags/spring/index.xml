<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Spring on 修仙下属委员会</title>
    <link>https://maoyanting.github.io/tags/spring/</link>
    <description>Recent content in Spring on 修仙下属委员会</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 22 Oct 2018 22:49:08 +0000</lastBuildDate>
    
	<atom:link href="https://maoyanting.github.io/tags/spring/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Spring-sleuth</title>
      <link>https://maoyanting.github.io/post/spring-sleuth/</link>
      <pubDate>Mon, 22 Oct 2018 22:49:08 +0000</pubDate>
      
      <guid>https://maoyanting.github.io/post/spring-sleuth/</guid>
      <description>&lt;p&gt;有时候，定位bug真的是个很麻烦的事情呢&lt;/p&gt;

&lt;p&gt;我们可以简单借用一下Spring Cloud Sleuth&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Spring-全局异常拦截</title>
      <link>https://maoyanting.github.io/post/spring-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA/</link>
      <pubDate>Tue, 16 Oct 2018 15:49:06 +0000</pubDate>
      
      <guid>https://maoyanting.github.io/post/spring-%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA/</guid>
      <description>&lt;p&gt;Spring MVC那一篇里提到了异常拦截来做参数校验返回，那里是对特定的 &lt;code&gt;controller&lt;/code&gt; 做异常捕捉，但是我们也可以选择全局拦截处理&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Spring（未完）</title>
      <link>https://maoyanting.github.io/post/spring/</link>
      <pubDate>Mon, 17 Sep 2018 11:56:06 +0000</pubDate>
      
      <guid>https://maoyanting.github.io/post/spring/</guid>
      <description>&lt;p&gt;spring 是一个 &lt;strong&gt;轻量级&lt;/strong&gt;的 实现&lt;strong&gt;IOC&lt;/strong&gt; 和 &lt;strong&gt;AOP&lt;/strong&gt;的框架。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>翻译-Building a RESTful Web Service</title>
      <link>https://maoyanting.github.io/post/%E7%BF%BB%E8%AF%91-building-a-restful-web-service/</link>
      <pubDate>Wed, 14 Feb 2018 21:00:27 +0000</pubDate>
      
      <guid>https://maoyanting.github.io/post/%E7%BF%BB%E8%AF%91-building-a-restful-web-service/</guid>
      <description>&lt;p&gt;翻译——使用Spring创建一个RESTful Web Service&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Spring-注释</title>
      <link>https://maoyanting.github.io/post/spring-%E6%B3%A8%E9%87%8A/</link>
      <pubDate>Thu, 11 Jan 2018 15:49:06 +0000</pubDate>
      
      <guid>https://maoyanting.github.io/post/spring-%E6%B3%A8%E9%87%8A/</guid>
      <description>注释 @Component： 功能：表明该类会作为组件类，并告知Spring要为此创建bean
下述这 3 个注释和 @Component 是等效的，但是从注释类的命名上，很容易看出这 3 个注释分别和持久层、业务层和控制层（Web 层）相对应。
@Service 用于标注业务层组件
@Controller 用于标注控制层组件
@Repository 用于标注数据访问组件，即DAO组件
@Component 泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注。
@ComponentScan： 功能：在Spring中启用组件扫描（默认组件扫描不启动），默认扫描与配置类相同的包；
@ComponentScan（”packageName&amp;rdquo;）
指明是基础包：@ComponentScan（basePackages=”package1Name”）@ComponentScan（basePackages={”package1Name”,”package2Name”}）
另一种方式：@ComponentScan（basePackagesClasses={ package1Name.class , package2Name.class } ）
@Autowired: 功能：声明要进行自动装配
使用：在构造器和方法 上
默认按类型装配，默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置它的required属性为false，如：@Autowired(required=false) ，如果我们想使用名称装配可以结合@Qualifier注解进行使用。
加上@Autowired后不需要getter()和setter()方法，Spring也会自动注入。
@Qualifier 功能：按名字装配bean
当我们在 Spring 容器中配置了两个类型为 Office 类型的 Bean，当对 Boss 的 office 成员变量进行自动注入时，Spring 容器将无法确定到底要用哪一个 Bean，就会发生异常。
Spring 允许我们通过 @Qualifier 注释指定注入 Bean 的名称，这样歧义就消除了，所以 @Autowired 和 @Qualifier 结合使用时，自动注入的策略就从 byType 转变成 byName 了。
@Resource 功能：按名字装配bean
是JDK1.6支持的注解（非Spring），默认按照名称进行装配。
名称可以通过name属性进行指定，如果没有指定name属性，当注解写在字段上时，默认取字段名，按照名称查找，如果注解写在setter方法上默认取属性名进行装配。当找不到与名称匹配的bean时才按照类型进行装配。但是需要注意的是，如果name属性一旦指定，就只会按照名称进行装配。
@Configuration： 表明此类是个配置类</description>
    </item>
    
    <item>
      <title>翻译-Spring for Apache Kafka</title>
      <link>https://maoyanting.github.io/post/%E7%BF%BB%E8%AF%91-spring-for-apache-kafka/</link>
      <pubDate>Mon, 08 Jan 2018 12:27:46 +0000</pubDate>
      
      <guid>https://maoyanting.github.io/post/%E7%BF%BB%E8%AF%91-spring-for-apache-kafka/</guid>
      <description>&lt;p&gt;翻译——Spring for Apache Kafka官方文档&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>JavaWeb-WebSocket在Spring&#43;React的实现</title>
      <link>https://maoyanting.github.io/post/javaweb-websocket%E5%9C%A8spring&#43;react%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Fri, 05 Jan 2018 11:27:46 +0000</pubDate>
      
      <guid>https://maoyanting.github.io/post/javaweb-websocket%E5%9C%A8spring&#43;react%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <description>背景 先说一下别的轮询方式： ajax轮询：让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。 long poll：浏览器发起连接后，如果没消息，就一直不返回Response给浏览器。直到有消息才返回，返回完之后，浏览器再次建立连接，周而复始。
ajax轮询 需要服务器有很快的处理速度和资源。 long poll 需要有很高的并发。
再说webSocket，先必须记住，webSocket是一个协议 我们使用的应该说是webSocket API
WebSocket是基于TCP的独立的协议。 和HTTP的唯一关联就是HTTP服务器需要发送一个“Upgrade”请求，即101 Switching Protocol到HTTP服务器，然后由服务器进行协议转换
//简单来说，就是我是从TCP那边继承过来的，干活需要依靠HTTP先帮我连接上
前端部分： 最简单的实现：
const ws = new WebSocket(&amp;quot;ws://echo.websocket.org/ws&amp;quot;); ws.onopen = function(evt) { console.log(&amp;quot;Connection open ...&amp;quot;); ws.send(&amp;quot;Hello WebSockets!&amp;quot;); }; ws.onmessage = function(evt) { console.log( &amp;quot;Received Message: &amp;quot; + evt.data); ws.close(); }; ws.onclose = function(evt) { console.log(&amp;quot;Connection closed.&amp;quot;); };  后端部分 先放官方文档(我用的是spring 4.3.13.RELEASE)
其实基本上就4四个部分： 1. 添加依赖 2. Handler类 3. 拦截器 4. 配置
添加依赖  &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.</description>
    </item>
    
  </channel>
</rss>